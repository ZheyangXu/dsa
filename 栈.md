# 栈

[155. 最小栈](https://leetcode.cn/problems/min-stack/)

> 思路1: 维护一个最小值 MinValue，初始化为整数最大值：$2^{31}$， push 时： 如果当前值比最小值小，则更新最小值；pop 时： 遍历栈更新最小值；

```go
type MinStack struct {
    Elements []int
    MinValue int
}


func Constructor() MinStack {
    return MinStack{
        Elements: []int{},
        MinValue: (1 << 31) - 1,
    }
}


func (this *MinStack) Push(val int)  {
    this.Elements = append(this.Elements, val)
    if val < this.MinValue {
        this.MinValue = val
    }
}


func (this *MinStack) Pop()  {
    top := this.Elements[len(this.Elements)-1]
    this.Elements = this.Elements[:len(this.Elements)-1]
    if this.MinValue == top {
        this.MinValue = (1 << 31) - 1
        for _, element := range this.Elements {
            if element < this.MinValue {
                this.MinValue = element
            }
        }
    }
}


func (this *MinStack) Top() int {
    top := this.Elements[len(this.Elements)-1]
    return top
}


func (this *MinStack) GetMin() int {
    return this.MinVa
```

> 思路2：用两个栈实现，一个最小栈始终保证最小值在顶部

```go
type MinStack struct {
    min []int
    stack []int
}

func Constructor() MinStack {
    return MinStack{
        min: make([]int, 0),
        stack: make([]int, 0)
    }
}

func (this *MinStack) Push(val int) {
    min :=  this.GetMin()
    if val < min {
        this.min = append(this.min, val)
    } else {
        this.min = append(this.min, min)
    }
    this.stack = append(this.stack, val)
}

func (this *MinStack) Pop {
    if len(this.stack) == 0 {
        return
    }
    this.stack = this.stack[:len(this.stack)-1]
    this.min = this.min[:len(this.min)-1]
}

func (this *MinStack) Top() int {
    if len(this.stack) == 0 {
        return 0
    }
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    if len(this.min) == 0 {
        return 1 << 31
    }
    min := this.min[len(this.min)-1]
    return min
}
```

[394. 字符串解码](https://leetcode.cn/problems/decode-string/)

