# 链表

## 定义

```go
type ListNode struct {
    Val int
    Next *ListNode
}
```

## 基础

* null/nil 异常处理
* dummy node 哑巴节点
* 快慢指针
* 插入一个节点到排序链表
* 从一个链表中移除一个节点
* 翻转链表
* 合并两个链表
* 找到链表的中间节点

## 例子

[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```go
func deleteDuplicates(head *ListNode) *ListNode {
    current := head
    for current != nil {
        for current.Next != nil && current.Val == current.Next.Val {
            current.Next = current.Next.Next
        }
        current = current.Next
    }
    return head
}
```

[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```go
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil {
        return head
    }

    dummy := &ListNode{Val: 0}
    dummy.Next = head
    head = dummy

    var rmVal int
    for head.Next != nil && head.Next.Next != nil {
        if head.Next.Val == head.Next.Next.Val {
            rmVal = head.Next.Val
            for head.Next != nil && head.Next.Val == rmVal {
                head.Next = head.Next.Next
            }
        } else {
            head = head.Next
        }
    }
    return dummy.Next
}
```

> 注意点 • A->B->C 删除 B，A.next = C • 删除用一个 Dummy Node 节点辅助（允许头节点可变） • 访问 X.next 、X.value 一定要保证 X != nil

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    for head != nil {
        temp := head.Next
        head.Next = prev

        prev = head
        head = temp
    }
    return prev
}
```

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    if head == nil {
        return head
    }

    dummy := &ListNode{Val: 0}
    dummy.Next = head
    head = dummy

    var prev *ListNode
    i := 0
    for i < left {
        prev = head
        head = head.Next
        i++
    }

    var j = i
    var next *ListNode
    var mid = head
    for head != nil && j <= right {
        temp := head.Next
        head.Next = next
        next = head
        head = temp
        j++
    }
    prev.Next = next
    mid.Next = head
    return dummy.Next
}
```

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }

    var dummy = &ListNode{Val: 0}
    var head = &ListNode{Val: 0}
    dummy.Next = head
    
    for list1 != nil || list2 != nil {
        if list1 == nil {
            for list2 != nil {
                head.Next = list2
                list2 = list2.Next
                head = head.Next
            }
            break
        }
        if list2 == nil {
            for list1 != nil {
                head.Next = list1
                list1 = list1.Next
                head = head.Next
            }
            break
        }
        if list1.Val <= list2.Val {
            head.Next = list1
            list1 = list1.Next
        } else {
            head.Next = list2
            list2 = list2.Next
        }
        head = head.Next
    }
    return dummy.Next.Next
}
```

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{Val: 0}
    head := dummy

    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            head.Next = list1
            list1 = list1.Next
        } else {
            head.Next = list2
            list2 = list2.Next
        }
        head = head.Next
    }

    for list1 != nil {
        head.Next = list1
        list1 = list1.Next
        head = head.Next
    }

    for list2 != nil {
        head.Next = list2
        list2 = list2.Next
        head = head.Next
    }
    return dummy.Next
}
```

[86. 分隔链表](https://leetcode.cn/problems/partition-list/)

```go
func partition(head *ListNode, x int) *ListNode {
    if head == nil {
        return head
    }

    headDummy := &ListNode{Val: 0}
    tailDummy := &ListNode{Val: 0}
    tail := tailDummy
    headDummy.Next = head
    head = headDummy
    for head.Next != nil {
        if head.Next.Val < x {
            head = head.Next
        } else {
            t := head.Next
            head.Next = head.Next.Next
            tail.Next = t
            tail = tail.Next
        }
    }
    tail.Next = nil
    head.Next = tailDummy.Next
    return headDummy.Next
}
```
