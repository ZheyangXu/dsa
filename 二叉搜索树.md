# 二叉搜索树

## 例子

[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```go
func isValidBST(root *TreeNode) bool {
    if root == nil {
        return   true
    }
    high := math.MaxInt64
    low := math.MinInt64

    return helper(root, low, high)

}

func helper(root *TreeNode, low, high int) bool {
    if root == nil {
        return true
    }
    
    if root.Val <= low || root.Val >= high {
        return false
    }

    return helper(root.Left, low, root.Val) && helper(root.Right, root.Val, high)
}
```

```go
func isValidBST(root *TreeNode) bool {
    return dfs(root).valid
}

type ResultType struct {
    max int
    min int
    valid bool
}

func dfs(root *TreeNode) ResultType {
    var result ResultType
    if root == nil {
        result.max = -1 << 63
        result.min = 1 << 63 - 1
        result.valid = true
        return result
    }

    left := dfs(root.Left)
    right := dfs(root.Right)
    
    if root.Val > left.Max && root.Val < right.min && left.valid && right.valid {
        result.valid = true
    }
    result.max = Max(max(left.max, right.max), root.Val)
    result.min = Min(Min(left.min, right.min), root.Val)
    return result
}

func Max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func Min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        root = &TreeNode{Val: val}
        return root
    }
    if root.Val > val {
        root.Left = insertIntoBST(root.Left, val)
    } else {
        root.Right = insertIntoBST(root.Right, val)
    }
    return root
}
```

[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return root
    }

    if root.Val < key {
        root.Right = deleteNode(root.Right, key)
    } else if root.Val > val {
        root.Left = deleteNode(root.Left, key)
    } else {
        if root.Left == nil {
            return root.Right
        } else if root.Right == nil {
            return root.Left
        } else {
            cur := root.Right
            for cur.Left != nil {
                cur = cur.Left
            }
            cur.Left = root.Left
            return root.Right
        }
    }
    return root
}
```
