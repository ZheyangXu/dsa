# 二叉树

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

## 遍历

前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树；

中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树；

后序遍历：先后续遍历左子树，再后续遍历右子树，再访问根节点

* 以根访问的顺序决定是什么遍历；
* 左子树都是优先右子树

### 递归序

```go
func trversal(root *TreeNode) { 
    if root == nil { 
        return
    }

    fmt.Println(root.Val) // 先序遍历
    trversal(root.Left)
    // fmt.Println(root.Val) // 中序遍历
    trversal(root.Right)
    // fmt.Println(root.Val) // 后序遍历
}
```

### 前序遍历(非递归)

```go
func preOrderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }

    result := make([]int, 0)
    stack := make([]*TreeNode, 0)

    for root != nil || len(stack) != 0 {
        for root != nil { 
            // 前序遍历，所以先保存结果
            result = append(result, root.Val)
            stack = append(stack, root)
            root = root.Left
        }
        
        // pop
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        root = node.Right
    }

    return result
}
```

### 中序遍历(非递归)

```go
// 通过 stack 保存已访问的元素，用于原路放回
func inOrderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root == nil {
        return nil
    }

    stack := make([]*TreeNode, 0)
    for root != nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }

        // 弹出
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // 中序遍历，中间处理
        result = append(result, node.Val)
        root = node.Right
    }
}
```

#### 例子：合法二叉搜索树

[面试题 04.05. 合法二叉搜索树](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

```go
// 中序遍历（递归）解法
func isValidBST(root *TreeNode) bool {

    lo := math.MinInt64
    hi := math.MaxInt64
    return inOrderTraversal(root, lo, hi)
    
}

func inOrderTraversal(root *TreeNode, lo int, hi int) bool {
    
    if root == nil {
        return true
    }

    /* 
    满足三个条件：
        1. 左子树是二叉搜索树；
        2. 右子树是二叉搜索树；
        3. 左子树的最大值小于 root 的值小于右子树的最小值；
    */
    inOrderTraversal(root.Left, lo, root.Val) 
    if root.Val <= lo || root.Val >= hi {
        return false
    }
    inOrderTraversal(root.Right, root.Val, hi)
    
    return inOrderTraversal(root.Left, lo, root.Val) && inOrderTraversal(root.Right, root.Val, hi)
}
```

```go
// 中序遍历（非递归）解法
func isValidBST(root *TreeNode) bool {
    stack := []*TreeNode{}
    inorder := math.MinInt64

    for len(stack) > 0 || root != nil {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }

        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if root.Val <= inorder {
            return false
        }
        inorder = root.Val
        root = root.Right
    }

    return true
}
```

### 后序遍历(非递归)

```go
func postOrderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }

    result := make([]int, 0)
    stack := make([]*TreeNode, 0)
    var lastVisit *TreeNode
    for root != nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }

        // 这里先看看，不弹出
        node := stack[len(stack)-1]
        if node.Right == nil || node.Right == lastVisit {
            // 弹出
            stack = stack[:len(stack)-1]
            result = append(result, node.Val)

            // 标记当前这个节点已经弹出过
            lastVisit = node
        } else {
            root = root.Right
        }
    }
}
```

### 前序遍历（DFS）

#### DFS 深度搜索 -- 从上到下

```go
func preOrderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    dfs(root, &result)
    return result
}

// 深度遍历，结果指针作为参数传入到函数内部
func dfs(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }

    *result = append(*result, root.Val)
    dfs(root.Left, result)
    dfs(root.Right, result)
}
```

#### DFS 深度搜索 -- 从下向上（分治法）

```go
func preOrderTraversal(root *TreeNode) []int {
    result := divideAndConquer(root)
    return result
}

func divideAndConquer(root *TreeNode) []int {
    result := make([]int, 0)
    if root == nil {
        return result
    }

    // Divide
    left := divideAndConquer(root.Left)
    right := divideAndConquer(root.Right)
    // Conquer
    result = append(result, root.Val)
    result = append(result, left...)
    result = append(result, right...)
    return result
}

```

> DFS 深度搜索（从上到下） 和分治法区别：前者一般将最终结果通过指针参数传入，后者一般递归返回结果最后合并.
